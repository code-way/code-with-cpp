// Topological Sort Using DFS Algorithm
// Simple algorithm that outputs linear ordering of vertices of the graph,such that for every edge(u->v) vertex u comes before vertex v in the ordering.
// Can be done slightly modified both BFS and DFS.
// Works only on DAG's: Directed Acyclic Graph

// It is basically a depencies graph.
// Every node is dependent on each other but there should be atleast one node that would not dependent on any other node (bcz we have to start from that node only)

// Complexity : Linear O(V+E)

// Applications:
// Finding out a possible sequence to finish task/programming modules
// eg:- English -> Maths -> Programming Logic -> Python -> HTML -> CSS -> JS -> Java -> Web Development
// Installing of packages in a Linux System, all dependencies/packages are installed first in the order generated by Topological Sort.

#include<bits/stdc++.h>
using namespace std;

template<typename T>
class Graph{
    int V;
	map<T,list<T> > adjList;
public:
	void addEdge(T u,T v,bool bid=true){
		 adjList[u].push_back(v);
		 if(bid){
		 	adjList[v].push_back(u);
		 }
	}
	void dfsHelper(T src, map<T,bool>& vis, list<T>& ordering){
		// whenever come to a node, mark it visited
		vis[src] = true;
		// Try to find out a node which is neighbour of current node and not yet visited 
		for(auto neighbours: adjList[src]){
			if(!vis[neighbours]){
				dfsHelper(neighbours,vis,ordering);
			}
		}
		// At this point all the children of current node have been visited
		// So we can add current node to the list 
		// (why do we add to front bcz if the node is added then it's dependent node will be add before that node)
		ordering.push_front(src);
	}
	void dfsTopological(){
	    // First mark all nodes as unvisited
		map<T,bool> vis;
		for(auto i:adjList){
			T node = i.first;
			vis[node] = false;
		}
		// To store the ordering we can use list,vector,stack (here we use list - bcz it has function to push the element front also) if we use vector then we to reverse same with stack
		list<T> ordering;
		for(auto i:adjList){
			T node = i.first;
			if(!vis[node]){
				dfsHelper(node,vis,ordering);
			}
		}
		for(auto element:ordering){
			cout<<element<<"-> ";
		}
	}
};
int main(){
	Graph<string> g;
	g.addEdge("English","Programming Logic",false);
	g.addEdge("Maths","Programming Logic",false);
	g.addEdge("Programming Logic","HTML",false);
	g.addEdge("Programming Logic","Python",false);
	g.addEdge("Programming Logic","Java",false);
	g.addEdge("Programming Logic","JS",false);
	g.addEdge("HTML","CSS",false);
	g.addEdge("CSS","JS",false);
	g.addEdge("JS","Web Development",false);
	g.addEdge("Python","Web Development",false);
	g.addEdge("Java","Web Development",false);
	g.dfsTopological();
	return 0;
}